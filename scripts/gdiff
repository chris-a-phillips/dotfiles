#!/bin/bash
#
# Generate git diff patches
. _utils

#######################################
# Generate git diff patches with enhanced features
# Arguments:
#   $1 - Base branch (default: develop)
#   $2 - Target branch/commit (default: HEAD)
#   $3 - Output file (optional, will auto-generate if not provided)
# Outputs:
#   Creates a patch file with the diff
#######################################

# Parse logging arguments first
remaining_args=$(parse_log_args "$@")
set -- $remaining_args

# Generate default output filename
generate_output_filename() {
    local base_branch="$1"
    local target_branch="$2"
    local timestamp=$(generate_timestamp)
    local current_branch=$(get_current_branch)
    
    # Create a descriptive filename
    if [ "$target_branch" = "HEAD" ]; then
        echo "${current_branch}_vs_${base_branch}_${timestamp}.patch"
    else
        echo "${target_branch}_vs_${base_branch}_${timestamp}.patch"
    fi
}

# Validate git repository and branches
validate_inputs() {
    local base_branch="$1"
    local target_branch="$2"
    
    # Check if we're in a git repository
    if ! is_git_repo; then
        error_exit "Not in a git repository"
    fi
    
    # Check if base branch exists
    if ! branch_exists "$base_branch"; then
        error_exit "Base branch '$base_branch' not found locally or remotely"
    fi
    
    # Check if target branch/commit exists (unless it's HEAD)
    if [ "$target_branch" != "HEAD" ]; then
        if ! git rev-parse --verify "$target_branch" >/dev/null 2>&1; then
            error_exit "Target '$target_branch' not found"
        fi
    fi
}

# Show diff statistics
show_diff_stats() {
    local base_branch="$1"
    local target_branch="$2"
    
    print_header "Diff Statistics"
    
    # Count files changed
    local files_changed=$(git diff --name-only $base_branch...$target_branch | wc -l)
    echo -e "Files changed: ${YELLOW}$files_changed${NC}"
    
    # Count lines added/removed
    local lines_stats=$(git diff --stat $base_branch...$target_branch | tail -1)
    if [ -n "$lines_stats" ]; then
        echo -e "Lines changed: ${YELLOW}$lines_stats${NC}"
    fi
    
    # Show file types
    print_header "File types changed"
    local file_types=$(git diff --name-only $base_branch...$target_branch | sed 's/.*\.//' | sort | uniq -c | sort -nr)
    if [ -n "$file_types" ]; then
        echo "$file_types" | head -10
    else
        echo "   No files with extensions"
    fi
}

# Generate the patch
generate_patch() {
    local base_branch="$1"
    local target_branch="$2"
    local output_file="$3"
    
    info "Generating patch from $base_branch...$target_branch"
    
    # Show what will be included
    show_diff_stats "$base_branch" "$target_branch"
    
    echo
    info "Generating patch file: $output_file"
    
    # Generate the patch
    if git diff $base_branch...$target_branch > "$output_file"; then
        local file_size=$(get_file_size "$output_file")
        print_success "Patch created successfully: $output_file (${file_size})"
        
        # Show patch summary
        print_header "Patch Summary"
        echo -e "Base branch: ${YELLOW}$base_branch${NC}"
        echo -e "Target: ${YELLOW}$target_branch${NC}"
        echo -e "Output: ${YELLOW}$output_file${NC}"
        echo -e "Size: ${YELLOW}$file_size${NC}"
        
        # Show how to apply the patch
        echo
        print_header "To apply this patch"
        echo "  git apply $output_file"
        echo "  # or"
        echo "  patch -p1 < $output_file"
        
    else
        error_exit "Failed to generate patch"
    fi
}

# Show usage
show_usage() {
    echo "Usage: $0 [BASE_BRANCH] [TARGET_BRANCH] [OUTPUT_FILE]"
    echo ""
    echo "Arguments:"
    echo "  BASE_BRANCH    Base branch to compare from (default: develop)"
    echo "  TARGET_BRANCH  Target branch/commit to compare to (default: HEAD)"
    echo "  OUTPUT_FILE    Output patch file (optional, auto-generated if not provided)"
    echo ""
    echo "Examples:"
    echo "  $0                                    # develop...HEAD"
    echo "  $0 main                              # main...HEAD"
    echo "  $0 develop feature-branch            # develop...feature-branch"
    echo "  $0 main feature-branch my-patch.patch # Custom output file"
    echo ""
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo "  -s, --stats    Show only diff statistics (no patch file)"
    echo "  -p, --preview  Show diff preview (no patch file)"
    echo ""
    echo "Logging Options:"
    echo "  --debug        Show debug messages"
    echo "  --info         Show info messages"
    echo "  --warn         Show warning messages"
    echo "  --error        Show error messages only"
    echo "  --quiet        Suppress all messages"
}

# Show diff preview
show_preview() {
    local base_branch="$1"
    local target_branch="$2"
    
    print_header "Diff Preview"
    git diff --stat $base_branch...$target_branch
    echo
    print_header "First few changes"
    git diff $base_branch...$target_branch | head -50
    echo -e "${YELLOW}... (showing first 50 lines)${NC}"
}

main() {
    local base_branch="${1:-develop}"
    local target_branch="${2:-HEAD}"
    local output_file="$3"
    local show_stats_only=false
    local show_preview_only=false
    
    debug "Starting gdiff script"
    info "Parsing arguments and setting up logging"
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -s|--stats)
                show_stats_only=true
                shift
                ;;
            -p|--preview)
                show_preview_only=true
                shift
                ;;
            *)
                # This is handled by the main logic
                shift
                ;;
        esac
    done
    
    # Validate inputs
    validate_inputs "$base_branch" "$target_branch"
    
    # Handle different modes
    if [ "$show_stats_only" = true ]; then
        debug "Showing stats only"
        show_diff_stats "$base_branch" "$target_branch"
        exit 0
    fi
    
    if [ "$show_preview_only" = true ]; then
        debug "Showing preview only"
        show_preview "$base_branch" "$target_branch"
        exit 0
    fi
    
    # Generate output filename if not provided
    if [ -z "$output_file" ]; then
        output_file=$(generate_output_filename "$base_branch" "$target_branch")
        debug "Generated output filename: $output_file"
    fi
    
    # Check if output file already exists
    if file_exists "$output_file"; then
        print_warning "Output file '$output_file' already exists"
        if confirm_action "Overwrite?"; then
            info "Overwriting existing file"
        else
            info "Operation cancelled"
            exit 0
        fi
    fi
    
    # Generate the patch
    debug "Generating patch"
    generate_patch "$base_branch" "$target_branch" "$output_file"
    
    info "Patch generation completed successfully"
}

main "$@"

